3번 sql

솔

1번 끼리끼리 팰린드롬

```python
#문자열 s가 주어진다. s = ['문자열1', '문자열2', '문자열3']

for one in s: # 문자열 하나씩 탐색하면서 팰린드롬수인지 확인한다.
    #하나의 문자열 하나 one을 세 그룹으로 나눈다.
    group1 = ''
    group2 = ''
    group3 = ''
    for c in s:
        if c.isalpha()==True:
            group1 += c
        elif
    #세그룹으로 나눠진 후
    intergrated = [group1, group2, group3]
    
    status = True
    for p in intergrated: #한 그룹씩 탐색하며 
        #하나라도 걸리면 False로 변경
   if stATUS == tRUE@여전히 튜라면 세그룹 모두 팰린드롬 
POSSIBLE.APPEND(ONE)
    
            
```





2번

어려운 문제였는데 시간이 부족해서 일단 거기 있는 테케는 다 맞추긴 했다. 풀 수는 있을거같았는데 1, 3번을 30분만에 풀고나니, 30분으로 이 문제를 해결하기는 역부족이였다.

점수는 사실 안구해도 되는 문제. 어차피 카드를 서로 바꾸는 '최소 갯수'만 리턴하면 되는 문제이기 때문에

최대한 한곳에 같은 요소가 많이, 다른 한곳에도 같은 요소가 많이있을때까지 카드를 교환한다.

그 최소 교환횟수를 리턴하면 되는 문제이다.

정확도를 100으로 할려면 많은 생각을 해야하는 문제이다.

즉, 점수를 구할 필요는 없고, 한 곳에 최대한 같은 요소가 많이 들어갈때까지만 (=그때 일일이 카운팅 해야함) 시도하면 된다, 결국 그 카운팅최종값을 리턴.

​    

```python
if len(set(cards1)) == 1 or len(set(cards2)) == 1: #한곳이 모두 하나의 카드로 몰려있어 옮길(=교환할) 필요가 전혀 없는 경우
    return 0

if len(set(cards1)) == 2 or len(set(cards2)) == 2:
    return 2
elif len(set(cards1)) == 3 or len(set(cards2)) == 3:
    return 3
else:
    return 4 #결국 4로 변경. 앞에서 이미 다 해결될것 같았기 때문에
```

