총 5문제 중 4문제 선택하여 풀이 

따라서 **총 4문제 중 3.5솔**을 하였다. (1, 2, 3, 4번 택)

테스트케이스도 다른 기업은 3개 주고 마는데 여기엔 기본예제 테스트케이스 3개 + 정확성 테스트케이스 각각 약 10개를 플러스로 줘서  보다 정확히 확인하며 풀 수 있었다.

1, 2, 3번 같은 경우는 꼼꼼하게 모두 체크, 테스트케이스도 전부다 맞춰 solve가 확실한 것 같다.

시간효율성 측면도 고려하면서 풀었고, 

4번 같은 경우는 무지성 구현 방식으로, 여러 조건문을 넣어 했지만 모든 테케를 통과하진 못했다. 예제를 보며 1인 경우를 일일이 조건문으로 구현해  맞는 테케수를 늘려갔다. 하지만 예제3 테케 통과 + 나머지 정확성 10개 테케 중 5개만 통과로 부분점수가 주어진다면 반점수가 주어지지 않을까 싶다.

아무튼 최근 몇 주간 코테 집중연습을 하면서 실력이 정말 많이 늘은 것 같다. 문제가 어려운 편에 속했는데 거의 다맞은걸 보니 ..

---

1. 중간점에서 가장 가까운 나무의 x좌표를 출력해라.

   이 문제는 쉬워서 바로 술술 풀었다.

   numbers 리스트가 주어진다. ex: [5, -1, 3, 9, 6]

   ```python
   numbers.sort() # 예시를 보아하니 x좌표 순으로 정렬을 해야했다.
   # [-1, 3, 5, 6, 9]
   ```

   ```python
   middle = (numbers[0]+numbers[-1]) / 2    # 첫나무+마지막나무 / 2  
   # middle = 4.0
   ```

   이때 '//'를 쓰면 안된다. 한 예시의 중간점이 1.5라고 했으니 소수점으로 나와야한다.

   ​    

   numbers = numbers[1:-1] #처음, 마지막 나무 제외

   ```python
   # 첫나무와 끝나무 사이 모든 나무들의 중간점과의 거리를 계산해 새 이차원리스트에 넣는다.
   new = []
   for num in numbers:
       new.append([num]) # [[-1], [3], [5], [6], [9]]
   for i in range(1, len(numbers)-1): #사이에 있는 나무들만 거리구해주기
       new[i].append(  abs(middle-num[i][0])  )
       
   print(new) # [[-1], [3, 1.0], [5, 1.0], [6, 2.0], [9]]
   ```

   ```python
   new = new[1:-1] # [[3, 1.0], [5, 1.0], [6, 2.0]]  #[해당나무의 x좌표, 중간점과의 거리]
   
   new.sort(key=lambda x:(x[1], x[0])) 
   # 가까운 거리순으로 정렬, 만약 가까운 지점의 나무가 여러개일 경우 x좌표순으로 정렬
   
   return new[0][0] #중간점과 가장 가까운 거리의 나무의 x좌표 리턴
   ```

   

---

2. 주어진 문자열 응축해 정규표현식으로 변환해라. 

   연속된 동일한 문자가 나오면 *로 응축한다.

   여러개의 ********같은 경우 *로 응축한다.

```python
'abbbcc' -> "ab*c*"
'wonderful' -> "wonderful"  # 더이상 짧게 표현이 불가능하다. 
'wwwwoooonnnnnnderfull' -> "w*o*n*derful*"
```

​    

문자열 s가 주어진다.

이전 문자와 동일한 것을 찾으면, 해당 문자를 *로 변환한다.

단 문자열 요소 변경은 불가능하기 때문에 문자열을 리스트로 변환해 요소를 변경한다.

```python
new_s = list(s)
before = s[0]
for i in range(1, len(s)): # abbbcc
    if before == s[i]: #해당 문자가 이전문자와 동일하다면 #동일한 문자가 연속해서 나오면 
        new_s[i] = '*' #이전과 같으면 *로 변경, 원본s는 바꾸지 않도록 한다.
    before = s[i]
new_s = ['a', 'b', '*', '*', 'c', '*']
    
s = "".join(new_s) #아마 다시 이렇게 했을듯. 다시 문자열로 바꾸는.
# s = "ab**c*"
```

​    

이제 ******** 여러개인 것을 *하나로 응축시키는 작업이 필요하다.  (이 부분을 좀 고민했었다.)

  ```python
  # s = "ab**c*"
  before = s[0]
  save_index = []
  for i in range(1, len(s)): # ab**c*
      if before == s[i] and before == '*': #해당 문자가 이전문자와 동일하고 앞문자가 *라면
          save_index.append(i)
      before = s[i]
  # save_index = [3]   
  # 이런식으로.. 제거해야할 부분을 저장해놓는다.
  remove를 하면 개수가 계속 실시간으로 줄어 자칫하면 인덱스 아웃 오류 걸린다. = 사실 늘 걸린다.. ㅎㅎ 해당 리스트 포문을 돌리고있는데 해당 리스트의 요소가 실시간으로 사라지면 i를 삭제하려해도 의도된 i위치를 삭제하게 되지 못하는것... 따라서 remove의 사용은 위험하다고 판단.
      
  그래서 생각해낸 방식: 다음과 같이 살린 인덱스만 순차적으로 문자열을 더해가며 답을 도출했다.
  answer = ''
  for i in range(len(s)):
      if i in save_index:
          pass
      else: #살린 인덱스
          answer += s[i]
          
   return answer  # 'ab*c*'
  ```

​    

---

3. 은행 계좌! 문자열 구현 문제

   nums = ['123-4567-8946', '5555-5555-777', . . .] 이렇게 여러개의 은행계좌들이 적힌 리스트가 주어진다. (넘어오는 리스트 인자를 nums로 가정)

   정상 계좌들 중에서, 각 은행의 계좌들이 몇 개 있는지 큰 순으로 정렬해서 리턴해라.

   ```python
   # 우선 문제 조건의 위배규칙1~4 조건에 해당되는  비정상 계좌를 먼저 판별했다.
   
   <비정상 계좌 조건>
   1. 계좌는 0~9숫자와 -로만 구성된다.
   2. 계좌는 -의 개수가 0개 이상 3개 이하이다.
   3. 계좌 첫번째와 마지막에 -가 들어갈 수 없다.
   4. 계좌 길이는 10자 이상 13자 이하만 될 수 있다.
   
   status = [ Ture*len(nums) ]
   # 비정상 계좌 판별
   for i in range(nums): #각 계좌마다 확인
       
       # [1] 계좌 한줄
       if not 0 <= nums[i].count('-') <= 3:
           status[i] = False # 규칙 2에 위배
           continue 
           #비정상계좌가 되면 효율을 위해 아래는 굳이 연산필요 X
           #break문은 쓰면 안됨. 전체 계좌가 비정상인지 판별을 해야하니까
       if not 10 <= len(nums[i]) <= 13:
           status[i] = False # 규칙 4에 위배
           continue 
           
           
       # [2] 계좌의 문자 하나씩 모두 탐색
       for j in range(len(nums[i])):  #nums[i]는 한 계좌 한줄
           
           if j == 0 or j == len(nums[i])-1: #계좌 첫번째나 마지막일때 '-'이면
               if nums[i][j] == '-':
                   status[i] = False # 규칙 3에 위배
                   continue 
               
           if not (nums[i][j].isdigit() == True or nums[i][j] == '-'): #숫자이거나 - 둘중 하나도 아니라면
               status[i] = False # 규칙 1에 위배
               continue 
   #for문 종료            
   .
   .
   .
   .
   문제에 주어진 조건들을 일련으로 구현해가며 정상계좌, 비정상계좌를 구분한다.
   그럼 status = [True, True, False, True, False...]
   이렇게 각 계좌가 정상인지, 비정상인지 구별돼 있을 것이다.
   ```
   
   이제 정상계좌만 가져와, ~
   
   ```python
   possible = []
   for i in range(nums): #각 계좌마다 확인
       if status[i] == True: # 정상계좌만 가져온다.
           
           result = ''
           for j in range(len(nums[i])):
               if nums[i][j].isdigit() == True: #숫자이면
                   result += '@'
               elif nums[i][j] == '-': # -이면
                   result += '-'
           possible.append(result) # '123-4567-8946' -> '@@@-@@@@-@@@@'
           
   문자열 형태의 개수를 세면 된다.
   문자열 형태가 같으면 같은 은행이다. 어차피 숫자 아니면 -로만 구성돼있기 때문.
   # print(possible) #각기 다른 문자열 형태 담겨있는 모습 확인
       
   # 각 문자열형태가 몇 개 있는지 센다. from collections import Counter문 필수
   dic = dict(Counter(possible))
   print(dic) #각 문자열형태가 몇개 있는지 확인
   # ex) dic = {'@@@-@@@@-@@@@': 3, '@@@@@@-@@@@@': 1, . . .}
   
   
   # 이제 각 은행계좌가 몇 개 있는지 정렬해서 리턴
   answer = []
   for key in dic.keys():
       answer.append(dic[key]) #숫자만 넣는다. 이때 문자열 형태까지 굳이 같이 넣어서 정렬할 필요없다. 각 은행의 계좌갯수 숫자만 넣어서 정렬하면 되기 때문에! (여기서 시간효율화를 위해 이렇게 코드를 바꿈)
   return sorted(answer, reverse=True)
   ```
   
   **Point**
   
   - 숫자는 @, -는 그대로 해서 '@@@-@@@@-@@@@'형태로 변환해  문자열 형태가 다르면 다른 은행으로 판별. -> 이 판단이 중요했다.
   
   - Counter를 이용해 해당 문자열형태의 개수를 구한다.
   
   - ex: [4,2,2,1] 리턴 

---

4. 마법진 문제 

   3행, 9개의 요소 => 정해져있다.

   ​    
   
   각 행의 합이 다른 행의 합과 모두 같고,
   
   각 열의 합이 다른 열과의 합과도 모두 같으면 마법진이라 부른다.
   
   ​    
   
   -> 일단 항상 들어맞는 경우가 있다. 예제를 보면 그 경우를 알 수 있다. 그 소수의 경우가 얼마 없으니 일일이 구현해 0.5솔을 했다.
   
   -> 나머지 케이스의 경우는  완전탐색을 시도해볼 필요가 있다. 완전탐색을 시도하다가 시간초과로 끝이 났다. 하지만 완전탐색을 시도하기 처음엔 우려가 있었다. 일단 9개의 경우로 정해져 있으니 완탐을 하면 가능할 것 같긴 하다. 하지만 보통의 경우, 백준 플랫폼에서 <순서까지 고려하는 순열 라이브러리, 그것도 9개의 수> 방식을 시도하면 항상 시간초과 문제가 났었다. 이 문제에서도 역시 시간초과가 날거라 생각을 했고, 그래서 완탐을 쓰기가 조금 우려가 되어, 첫 번째에 기술한 소수의 경우를 일일이 구현을 했던 것이다.  아무튼 순서를 고려하는 순열 라이브러리를 이용해 딱 들어맞는 경우를 리턴하면 될 듯 하다.  시간초과가 나더라도 한 번 진심을 다해 풀어볼걸 그랬다. 약간의 아쉬움이 있는 문제이다.

---

5. 택X

   고급 알고리즘

---

- 문자열 구현에 치중해서 나옴 2문제나

- 이차원배열의 복사를 위해 copy모듈의 deepcopy() 이용

  일차원배열의 복사를 위해 list()도 사용. 원본을 복사할 일이 꽤 생겼었다.

- sort()도 1번, 3번에서 사용

- Counter 사용에 능숙해진 것이 이번 코테에서 많은 도움 되었다.

---

풀이순서

2번 -> 1번 -> 3번 -> 4번

2번이 1번보다 더 쉬울줄 알고 먼저 풀었는데 2번 풀고 1번으로 넘어가니 1번이 더 쉬웠다.

3번도 쭉쭉 풀다보니 맞았고, 4번에서 한시간반 넘게 남아서 해결하려 했지만 결국 해결하지 못했다.

---