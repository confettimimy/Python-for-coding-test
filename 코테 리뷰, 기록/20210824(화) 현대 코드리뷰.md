총 5문제 중 4문제 선택하여 풀이 

따라서 **총 4문제 중 3.5솔**을 하였다. (1, 2, 3, 4번 택)

테스트케이스도 다른 기업은 3개 주고 마는데 여기엔 기본예제 테스트케이스 3개 + 정확성 테스트케이스 각각 약 10개를 플러스로 줘서  보다 정확히 확인하며 풀 수 있었다.

1, 2, 3번 같은 경우는 꼼꼼하게 모두 체크, 테스트케이스도 전부다 맞춰 solve가 확실한 것 같다.

시간효율성 측면도 고려하면서 풀었고, 

4번 같은 경우는 무지성 구현 방식으로, 여러 조건문을 넣어 했지만 모든 테케를 통과하진 못했다. 예제를 보며 1인 경우를 일일이 조건문으로 구현해  맞는 테케수를 늘려갔다. 하지만 예제3 테케 통과 + 나머지 정확성 10개 테케 중 5개만 통과로 부분점수가 주어진다면 반점수가 주어지지 않을까 싶다.

아무튼 최근 몇 주간 코테 집중연습을 하면서 실력이 정말 많이 늘은 것 같다. 문제가 어려운 편에 속했는데 거의 다맞은걸 보니 ..지금이 포텐터질 시기인 것 같다. . (하핳) 이번주 포스코, kt도 잘봤으면 좋겠다.

---

1. 중간점에서 가장 가까운 나무의 x좌표를 출력해라.

   이 문제는 쉬워서 바로 술술 풀었다.

   numbers 리스트가 주어진다. ex: [5, -1, 3, 9, 6]

   ```python
   numbers.sort() # 예시를 보아하니 x좌표 순으로 정렬을 해야했다.
   # [-1, 3, 5, 6, 9]
   ```

   ```python
   middle = (numbers[0]+numbers[-1]) / 2    # 첫나무+마지막나무 / 2  
   # middle = 4.0
   ```

   이때 '//'를 쓰면 안된다. 한 예시의 중간점이 1.5라고 했으니 소수점으로 나와야한다.

   ​    

   numbers = numbers[1:-1] #처음, 마지막 나무 제외

   ```python
   # 첫나무와 끝나무 사이 모든 나무들의 중간점과의 거리를 계산해 새 이차원리스트에 넣는다.
   new = []
   for num in numbers:
       new.append([num]) # [[-1], [3], [5], [6], [9]]
   for i in range(1, len(numbers)-1): #사이에 있는 나무들만 거리구해주기
       new[i].append(  abs(middle-num[i][0])  )
       
   print(new) # [[-1], [3, 1.0], [5, 1.0], [6, 2.0], [9]]
   ```

   ```python
   new = new[1:-1] # [[3, 1.0], [5, 1.0], [6, 2.0]]  #[해당나무의 x좌표, 중간점과의 거리]
   
   new.sort(key=lambda x:(x[1], x[0])) 
   # 가까운 거리순으로 정렬, 만약 가까운 지점의 나무가 여러개일 경우 x좌표순으로 정렬
   
   return new[0][0] #중간점과 가장 가까운 거리의 나무의 x좌표 리턴
   ```

   

---

2. 주어진 문자열 응축해 정규표현식으로 변환해라. 

   연속된 동일한 문자가 나오면 *로 응축한다.

   여러개의 ********같은 경우 *로 응축한다.

```python
'abbbcc' -> "ab*c*"
'wonderful' -> "wonderful"  # 더이상 짧게 표현이 불가능하다. 
'wwwwoooonnnnnnderfull' -> "w*o*n*derful*"
```

​    

문자열 s가 주어진다.

이전 문자와 동일한 것을 찾으면, 해당 문자를 *로 변환한다.

단 문자열 요소 변경은 불가능하기 때문에 문자열을 리스트로 변환해 요소를 변경한다.

```python
new_s = list(s)
before = s[0]
for i in range(1, len(s)): # abbbcc
    if before == s[i]: #해당 문자가 이전문자와 동일하다면 #동일한 문자가 연속해서 나오면 
        new_s[i] = '*' #이전과 같으면 *로 변경, 원본s는 바꾸지 않도록 한다.
    before = s[i]
# new_s = ['a', 'b', '*', '*', 'c', '*']
```

​    

이제 ******** 여러개인 것을 *하나로 응축시키는 작업이 필요하다.

이 부분을 좀 고민했었다.

  ```python
  before = s[0]
  save_index = []
  for i in range(1, len(s)): # abbbcc
      if before == s[i]: #해당 문자가 이전문자와 동일하다면 #동일한 문자가 연속해서 나오면
          save_index.append(i)
      before = s[i]
  # save_index = [2, 3, 5]
      
  이런식으로.. 제거해야할 부분을 저장해놓는다.
  remove를 하면 개수가 계속 실시간으로 줄어 자칫하면 인덱스 아웃 오류 걸린다. = 사실 늘 걸린다.. ㅎㅎ 해당 리스트 포문을 돌리고있는데 해당 리스트의 요소가 실시간으로 사라지면 i를 삭제하려해도 의도된 i위치를 삭제하게 되지 못하는것... 따라서 remove의 사용은 위험하다고 판단.
      
  그래서 생각해낸 방식: 다음과 같이 살린 인덱스만 순차적으로 문자열을 더해가며 답을 도출했다.
  answer = ''
  for i in range(len(s)):
      if i in save_index:
          pass
      else: #살린 인덱스
          answer += s[i]
          
   return answer
  ```



---

3. 은행!!!!!계좌! 문자열 구현 문제

   숫자는 @로 변환하고 -는 그대로 -

   문자열 형태... 

   Counter  해당 문자열형태의 개수를 구한다.

   [4,2,2,1] 리턴 정렬해서 리턴해라

---

4. 마법진 문제

   3행, 9개의 요소 => 정해져있다.

   

---

5. 택X

   고급 알고리즘

---

- 문자열 구현에 치중해서 나옴 2문제나

- 이차원배열의 복사를 위해 copy모듈의 deepcopy() 이용

  일차원배열의 복사를 위해 list()도 사용. 원본을 복사할 일이 꽤 생겼었다.

- sort()도 1번, 3번에서 사용

- Counter 사용에 능숙해진 것이 이번 코테에서 많은 도움 되었다.

---

풀이순서

2번 -> 1번 -> 3번 -> 4번

2번이 1번보다 더 쉬울줄 알고 먼저 풀었는데 2번 풀고 1번으로 넘어가니 1번이 더 쉬웠다.

3번도 쭉쭉 풀다보니 맞았고, 4번에서 한시간반 넘게 남아서 해결하려 했지만 결국 해결하지 못했다.

---