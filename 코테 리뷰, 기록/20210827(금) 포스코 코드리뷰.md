## 1번 

(모 기업 코테 1번문제와 똑같았던 문제)

숫자들이 담긴 리스트 ls가 주어지면, **유일하게 만들기** (중복되는 숫자가 하나도 없도록)

오름차순으로 정렬한뒤 for문을 1번 써서  최소횟수 구하기

​    

정렬이 필수 작업이라는 것을 알아챘다.

for문을 한번만 돌면서 최솟값을 찾으려면 처음에 오름차순으로 정렬 작업을 진행해야한다.

★ 정렬을 하지 않으면 for문 한번이 끝났을때  또다시 뒤돌아 탐색하며 카운팅을 해야 하는데 그럼 최솟값을 구하지 못하게 된다.

​    

정렬을 굳이해서 틀리면 어쩌지? 생각이 들어서

한번 정렬 시키지 않은 채로 종이에 직접 계산을 해보았고,  내가 짠 코드 (= for문 한번만 돌려 최솟값 구하기)로 하려면  리스트 요소들을 다시 (거꾸로든지) 탐색하면서 유일하게 만들어야 했다. 유일하게 만들어지지 않았기 때문에... for문 한번으로는 안된다는 사실.

따라서 무조건 정렬 작업을 시행한 후, for문 한번 돌며 유일하지 않으면 +1 할때마다 카운팅 함으로써 최솟값을 도출해냈다.

while문 무작정으로 쓰지않고, **그리디식으로 접근해, for문 한번만 돌며, 최대한 효율적으로 접근해 solve**한 문제이다. 잘 풀었다!

​    

---

## 2번

<문제 명시 조건>

3일째 착용했으면 마스크 폐기

미세먼지가 '아주나쁨'이면 한번 쓰고 버리기

미세먼지가 '나쁨' 두번이면 이틀쓰고 폐기해야함.. 뭐 이렇게 표를 분석해 명시조건을 파악해야 한다.

일주일 동안 착용한 마스크 개수는 총 몇개인가? 

이때, 미세먼지 수준도 3단계중 하나로 각각 표기되어 리스트로 주어짐

```python
mask_count = 0

while Ture:
    day += 1 # 하루 지나면 
    
    if day==3 and : # +3일동안 미세먼지가 보통이라면
        mask_count += 1  #여기서 카운팅 
        day = 0 #초기화
    
    
        
return mask_count
# 대략 이러한 구조로 풀었음
```



---

## 3번

로봇 완탐 문제

---

## 4번 sql

이번에는 엄청 쉽게 나옴. 거저 주는 문제

굳이 포인트가 있다면 정렬 2개가 포인트였던 문제.

```mysql
SELECT
FROM 
ORDER BY 칼럼1, 칼럼2 DESC;
# 칼럼1이 같을 시에는 칼럼2역순으로 정렬해라
```

