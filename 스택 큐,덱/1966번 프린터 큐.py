from collections import deque

t= int(input())

for _ in range(t): #왜이걸 3으로..그니까 틀렸지
    n, m = map(int, input().split())
    # m = 몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue에서 몇 번째에 놓여 있는지를 나타내는 정수 M
    ls = list(map(int, input().split())) #n개 문서의 중요도
    # [1, 2, 3, 4]

    q = deque(ls)
    
    for i in range(len(ls)):
        q[i] = (i, q[i]) #1 1 1과 같이 동일한 요소의 경우 위치는 다르기 때문에 위치를 기록해놓기
    #print(q)

    
    end = [] #처리 순서대로 넣을 리스트
    while True:
        if len(end) == n:
            break
        
        status = False
        compare = [ q[t][1] for t in range(1, len(q))]
        for k in compare:
            if q[0][1] < k: #뒤에 하나라도 우선순위가 높은 것이 있다면
                save = q.popleft() #뒤로 보내기
                q.append(save)
                status = True
                break
        #for문에서 한번이라도 걸린적이 없다면 = 첫번째 요소가 우선순위가 제일 놓다면
        if status == False:
            end.append(q[0])# 처리
            q.popleft()


    #print(end,'end') #처리 순서대로 저장돼있음
    for j in range(len(end)):
        if end[j][0] == m: #m은 위치
            print(j+1)
            break

'''<후기>
1. 덱(deque)을 좀 더 자유자재로 사용할 수 있게 되었다.
파이썬 레퍼런스를 참고하면 deque객체가 어떠한 메서드를 지원하는지 참고할 수 있다.
popleft()과 같은 기본 메서드 외에 리스트 자료형과 같이 remove()같은 메서드도 지원한다.

2. 처음에는 위치를 기억하기 위해 dict 딕셔너리 자료형을 이용하고, popleft()메서드를 사용하기 위헤
즉 자유자재로 양옆 요소를 빼고 추가하기 위해 deque덱 자료형으로 바꾸고 다시 원상태로 돌리고 이것을 반복했다.
하지만 이 경우 조심해야할 부분이 생긴다.
만약 [(1, 0), (2, 1), (3, 2), (4, 3)]을 deque()씌운다면 deque([1,2,3,4]) 이런식으로 위치로 기억해둔 곳이 다 날라가버린다.
따라서 고민을 계속 해보았고
결국 deque 자료형을 계속 사용하는 방식을 택했다.
위 풀이방식대로 deque([(1, 0), (2, 1), (3, 2), (4, 3)]) 이렇게 덱 구조에 위치를 기억하는 방식을 사용했다.
덱 구조도 사용법만 더 익숙해지면 리스트, 딕셔너리, 튜플 자료형과 같이 자유자재로 사용할 수 있으니 잘 활용하도록 하자.

즉..
위치 기억해놓는 것이 중요한 문제이다.
또한 1 1 1 1 9 1 과 같이 동일한 요소 1들이 존재할 경우, 같은 1이여도 위치는 다 다를 것이다.
따라서 위치를 기억해놓는 것이 관건이다.
본인은  [(1, 0), (2, 1), (3, 2), (4, 3)] 이렇게 위치를 기억해놓았다. 기존 딕셔너리나 리스트 자료형을 사용했던 것과 같이.
다만 덱 자료형을 이용해 이러한 구조로 위치를 기억해놓은 것은 이번이 처음이다.
앞으로 연습을 좀만 더 해서 deque를 자유자재로 쓸 수 있을 정도가 되게 문제를 더 풀어봐야겠다!
'''
