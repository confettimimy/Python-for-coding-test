12/1 코테 후기

1. 그리디 문제
풀다가 안풀려서 넘어가고 다시 돌아와서 푼 문제
풀다가 3-4분 남기고 모든 테케 돌아가기 성공
1번 문제에서 왜이렇게 시간썼나 모르겠다
그리디 시간 연습 좀 더해야겠다.





2. 2x2행렬 맵의 영화 좌석 배정 문제가 나와서 DFS 문제인줄 알았는데 아니였다. 이것도 마찬가지로 구현이나 그리디 문제인 것 같다.
(1.1) 위치에 첫 번째로 들어온 사람을 먼저 배치하고 두 번째 사람부터 이전 사람과 가장 멀리있는 위치에 좌석을 배치하란 문제였음.
다만 좌석을 배치할때 4개 정도 일련의 규칙이 있다.
반복문을 돌리고 그 안에 4개 규칙을 순서대로 코딩하면 되는 문제로 파악된다.
근데 그 과정이 조금 복잡했다. 만약 거리가 똑같으면 더 적은 열을 가진 위치에 배치하는 조건이였음.
아마 dfs를 구현했을 때처럼 방문처리도 필요했을 것이다. 이미 배치한 사람이 있으면 이제 나머지 좌석에서 가장 먼 거리에 사람을 배치해야하므로..
시간이 많았다면 천천히 풀었을 수도 있을 것 같은데 시간부족으로 결국 못풀었다.
이것만 풀면 올솔인데 시간연습좀 많이 해야겠다..ㅎㅎ

참고로 거리 구하기 공식은 정석적으로 구하는 것이 아닌, 문제에 나와있는 조건으로 거리를 구하는 것이였다.
두 점이 있으면 각각의 x, y 위치를 빼서 절댓값 씌워서 계산하는 그런 간단한.. 
다만 실제로 인덱스 위치는 (0,0)인데 문제상에서는 (1,1)로 계산해서 그 점에 유의해야 한다. (실수 주의)





3. N진법 문제가 나왔다.
10진법의 경우: 012345678910111213141516171819...
6진법의 경우: 012345101112131415...
2진법의 경우: 0110..어쩌구

여기서 매개변수의 인자로 n과 k가 들어온다.
n진법으로 주어졌을 때 k번째 인덱스의 값이 어떤 숫자인지 출력해라.

나는 문자열로 접근하였고,
k번째 숫자가 무엇인지 출력하면 되므로 k번째 숫자까지만 문자열을 생성했다. 예를 들어 1010101011110100100..이렇게 k번째까지만.

문제 예시를 보아하니 규칙을 찾을 수 있었다. 10번째부터는 0, 1, 2..이렇게 다시 반복되는게 아니라 10, 11, 12.. 이런식으로 반복됐다.
따라서
s = ''
for i in range(k):
   for a in range(p): # p진법이니까
      s += str(a)
   for b in range(p):
      s+= str(b+10)
   for c in range(p):
      s+= str(c+20)
   for d in range(p):
      s+= str(d+30)
이렇게 코딩했다.. 완벽한 접근은 아니지만 거기있던 테케는 모두 다 돌아갔다.
근데 아마 나중에 채점할 땐 몇 십개의 테케 중 몇 개가 조금 걸릴 것이다. 40번째 숫자 이내로 주어지는 테케만 다 돌아가고
그 이후 숫자가 주어지면 아마 틀릴 것.. 그래서 40 인덱스 이후 테케 부분에서 부분점수로 깎일 것 같다.
40까지만 한 이유는 50 이후부터는 거기있던 테케 한 개가 걸렸기 때문이다.
더 휼륭한 접근법을 찾아봐야겠다.





4. SQL문제
가장 먼저 풀었고 역시나 제일 쉬웠다.
EMPLOYEES, SELLINGS 테이블 두 개가 주어졌고, 3종류 이상의 차를 판 직원의 NAME과 ID, CAR_TYPE을 조회하란 문제였다.

나는 EMPLOYEES, SELLINGS 두 테이블을 그냥 JOIN했고
ON에는 EMPLOYEES.ID = SELLINGS.EMPLOYEE_ID 이런 식으로 써주었다. 둘의 KEY값이 전에 풀던 문제들과는 달리 상이했다. 이렇게도 하니까 됐다.
거기서 SELECT EMPLOYEES.NAME, EMPLOYEES.ID, SELLINGS.CAR_TYPE 이런 식으로 각 KEY값을 가진 테이블명을 앞에 각각 붙여주었다.
그리고 CAR_TYPE에 따라 COUNT를 묶어야하니 GROUP BY CAR_TYPE을 해주었고
HAVING절을 써서 COUNT()를 해준 걸로 기억난다.

SELECT / COUNT / GROUP BY / HAVING / JOIN 개념이 모두 사용된 문제. 
프로그래머스 SQL 고득점 킷을 다 풀어봤던 사람이라면 무난히 쉽게 풀 수 있는 문제였다.
