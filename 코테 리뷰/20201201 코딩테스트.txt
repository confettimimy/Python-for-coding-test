12/1 코테 후기

1. 그리디 문제.
마지막 투표자로서 리스트가 주어지면 그 값을 모두 다 다르게 만들어 유효한 숫자로 만들란 문제였다.
모두 다 유효한 값으로 만들기 위해 최소한 몇 번을 투표해야하는지 출력시켜야하는 문제.
단, 각 사람에게 단 한번만 투표할 수 있다.
1번문제인데 나는 좀 까다롭게 느껴졌다. 결국 다른 문제 풀다가 다시 돌아와 3~4분 남기고 성공시킨 문제였다..

주어진 각 투표수가 요소로 들어있는 리스트 ls가 들어왔다치면
나는 if len(ls) == len(set(ls)):
이런식으로 set 집합 자료형을 이용해 중복제거를 해주었고, 그래도 여전히 개수가 같다면 모두 다 다른 값인 것으로 판단해 문제에서 요구하는 0값을 출력해주었다.
그리고 if len(ls) != len(set(ls)):
이렇다면 중복되는 값이 존재한다는 소리이기 때문에 같은 값을 찾아 하나에게 투표해 +1을 해주었다.
근데 +1한 값이 또 리스트 내에 다른 값과 중복된다면 또 같은 처리로 반복..

위의 반복문을 빠져나와서도 여전히 모두 다 다른값으로 만들지 못했다면 불가한 경우이므로 -1을 출력시킨다.
이렇게 처리해주었다.

처음에는 정렬시키고 했다가 테케가 안돌아가서
정렬을 풀었더니 모든 테케가 다 돌아갔다.

리스트 내 동일한 값을 찾는 그런 함수를 찾다가 없어서...
동일한 값 찾는 방법을 더 공부해야겠다.
집합 자료형을 사용해 중복을 제거했던 접근은 최적의 접근이였던 것 같다.




2. 구현 문제.
2x2행렬 맵의 영화 좌석 배정 문제가 나와서 처음에는 이차원 배열의 그래프 탐색 dfs유형인줄 알았다.
(1.1) 위치에 첫 번째로 들어온 사람을 먼저 배치하고 두 번째 사람부터 이전 사람과 가장 멀리있는 위치에 좌석을 배치하란 문제였음.
다만 좌석을 배치할때 4개 정도 일련의 규칙이 있다.
반복문을 돌리고 그 안에 4개 규칙을 순서대로 코딩하면 되는 문제로 파악된다.
근데 그 과정이 조금 복잡했다. 만약 거리가 똑같으면 더 적은 열을 가진 위치에 배치하는 조건이였음.
아마 dfs를 구현했을 때처럼 방문처리도 필요했을 것이다. 이미 배치한 사람이 있으면 이제 나머지 좌석에서 가장 먼 거리에 사람을 배치해야하므로..
구현 문제 유형에 속하고, 문제에 주어진 조건대로 잘 코딩하면 됐던 문제.
다만 구현하기 조금 복잡+까다롭고 시간이 오래걸리는 문제이다.

참고로 거리 구하기 공식은 정석적으로 구하는 것이 아닌, 문제에 나와있는 조건으로 거리를 구하는 것이였다.
두 점이 있으면 각각의 x, y 위치를 빼서 절댓값 씌워서 계산하는 그런 간단한.. 
다만 실제로 인덱스 위치는 (0,0)인데 문제상에서는 (1,1)로 계산해서 그 점에 유의해야 한다. (실수 주의)




3. N진법 문제가 나왔다.
(3번문제인데 생각보다 어렵지 않았음, 다만 히든 테케에서 걸릴 위험이 많아 사람들이 다 여기서 걸렸을 것 같다.)

10진법의 경우: 012345678910111213141516171819...
6진법의 경우: 012345101112131415...
2진법의 경우: 0110..어쩌구

여기서 매개변수의 인자로 n과 k가 들어온다.
n진법으로 주어졌을 때 k번째 인덱스의 값이 어떤 숫자인지 출력해라.

나는 문자열로 접근하였고,
k번째 숫자가 무엇인지 출력하면 되므로 k번째 숫자까지만 문자열을 생성했다. 예를 들어 1010101011110100100..이렇게 k번째까지만.

문제 예시를 보아하니 규칙을 찾을 수 있었다. 10번째부터는 0, 1, 2..이렇게 다시 반복되는게 아니라 10, 11, 12.. 이런식으로 반복됐다.
따라서
s = ''
for i in range(k):
   for a in range(p): # p진법이니까
      s += str(a)
   for b in range(p):
      s+= str(b+10)
   for c in range(p):
      s+= str(c+20)
   for d in range(p):
      s+= str(d+30)
이렇게 코딩했다.. 완벽한 접근은 아니지만 거기있던 테케는 모두 다 돌아갔다.
근데 아마 나중에 채점할 땐 몇 십개의 테케 중 몇 개가 조금 걸릴 것이다. 40번째 숫자 이내로 주어지는 테케만 다 돌아가고
그 이후 숫자가 주어지면 아마 틀릴 것.. 그래서 40 인덱스 이후 테케 부분에서 부분점수로 깎일 것 같다.
40까지만 한 이유는 50 이후부터는 거기있던 테케 한 개가 걸렸기 때문이다.
더 휼륭한 접근법을 찾아봐야겠다.




4. SQL문제.
EMPLOYEES, SELLINGS 테이블 두 개가 주어졌고, 3종류 이상의 차를 판 직원의 NAME과 ID, CAR_TYPE을 조회하란 문제였다.

나는 EMPLOYEES, SELLINGS 두 테이블을 그냥 JOIN했고
ON에는 EMPLOYEES.ID = SELLINGS.EMPLOYEE_ID 이런 식으로 써주었다. 둘의 KEY값이 전에 풀던 문제들과는 달리 상이했다. 이렇게도 하니까 됐다.
거기서 SELECT EMPLOYEES.NAME, EMPLOYEES.ID, SELLINGS.CAR_TYPE 이런 식으로 각 KEY값을 가진 테이블명을 앞에 각각 붙여주었다.
그리고 CAR_TYPE에 따라 COUNT를 묶어야하니 GROUP BY CAR_TYPE을 해주었고
HAVING절을 써서 COUNT()를 해준 걸로 기억난다.

SELECT / COUNT / GROUP BY / HAVING / JOIN 개념이 모두 사용된 문제. 
프로그래머스 SQL 고득점 킷을 다 풀어봤던 사람이라면 무난히 쉽게 풀 수 있는 문제였다.
