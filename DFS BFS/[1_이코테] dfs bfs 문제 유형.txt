1차원 배열이나 2차원 배열을 그래프 형태로 생각하면 수월하게 문제를 풀 수 있다.

2차원 배열에서의 탐색 문제를 만나면 그래프 형태로 바꿔서 생각하면 풀이 방법을 조금 더 쉽게 떠올릴 수 있다.

-----------------------------------------------------------------------------------------------------------------

[DFS]
- 한 가지 정점과 연결된 모든 정점을 탐색해야 하는 경우
- 경로를 찾아야 되는 경우
- 사이클이 존재하는 경로 찾는 경우

[BFS]
- 최단 거리를 구해야하는 경우
- 최단 거리를 구하되 조건이 여러 개 존재하는 경우(방문한 지점도 다시 방문 가능)

-----------------------------------------------------------------------------------------------------------------

시작 지점에서 가까운 노드부터 차례대로 그래프의 모든 노드를 탐색하는 문제 -> bfs가 적절

해당 노드에 연결된 모든 노드들을 찾는문제라고 볼수있다.
DFS를 통해 구현해보자.

DFS와 BFS의 시간복잡도
두 방식 모두 조건 내의 모든 노드를 검색한다는 점에서 시간 복잡도는 동일.

-----------------------------------------------------------------------------------------------------------------

3. 깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS) 활용한 문제 유형/응용
DFS, BFS은 특징에 따라 사용에 더 적합한 문제 유형들이 있습니다.

​

1) 그래프의 모든 정점을 방문하는 것이 주요한 문제

단순히 모든 정점을 방문하는 것이 중요한 문제의 경우 DFS, BFS 두 가지 방법 중 어느 것을 사용하셔도 상관없습니다.

둘 중 편한 것을 사용하시면 됩니다.

​

2) 경로의 특징을 저장해둬야 하는 문제

예를 들면 각 정점에 숫자가 적혀있고 a부터 b까지 가는 경로를 구하는데 경로에 같은 숫자가 있으면 안 된다는 문제 등, 각각의 경로마다 특징을 저장해둬야 할 때는 DFS를 사용합니다. (BFS는 경로의 특징을 가지지 못합니다)

 

3) 최단거리 구해야 하는 문제

미로 찾기 등 최단거리를 구해야 할 경우, BFS가 유리합니다.

왜냐하면 깊이 우선 탐색으로 경로를 검색할 경우 처음으로 발견되는 해답이 최단거리가 아닐 수 있지만, 
너비 우선 탐색으로 현재 노드에서 가까운 곳부터 찾기 때문에경로를 탐색 시 먼저 찾아지는 해답이 곧 최단거리기 때문입니다.

 

이밖에도 

- 검색 대상 그래프가 정말 크다면 DFS를 고려
- 검색대상의 규모가 크지 않고, 검색 시작 지점으로부터 원하는 대상이 별로 멀지 않다면 BFS



출처: https://devuna.tistory.com/32 [튜나 개발일기📚]